#+TITLE: vim

* vim mode notes
** vim mode
+ Normal
+ Insert
+ last line mode
** notes 
都是前缀，还需要下个命令字符
d 单独 d 是删除当前行与上一行，前提还要是的再按下移动类的下个命令
d 作用完还在此模式，c 作用完进入插入模式
D 直接删除到行尾，C 是直接删除到行尾并进入插入模式   
y 是复制，p 是粘贴
Y 是复制当前光标到行尾
r 是一次性的替换当前字符，R 是从当前光标进入替换模式向右，直至 esc
S 删除本行，且光标到行首进入插入模式
** /
加一个单词然后在整个文档中搜索这个单词，然后用数字加 n 的组合来定位第几个单词。 
   如果我们想要单纯的只使用该单词比如 xin，那么我们可以用
   命令/\<xin\>来做到，其中\<表示匹配一个单词的开头，而\>
   则表示匹配一个单词的结束。 
   要找到这个 explode，就直接在命令模式下用/explode 就可以了
   ## vim 是支持正则表达式的
   因为正则表达式对于字符串的匹配来说提供了强劲的支持，vim 也自然对搜索有着强劲
   的支持。^字符匹配一行的开头，
   $匹配一行的结尾，
   比如/^the$是匹配一行之中只有 the 这个单词的情况，即我们必须以该单词
   开头又必须以该单词结尾，那这一行除了这个单词连空格都不
   能有。
.匹配到任何字符，比如 x.g 可以匹配 xig，还可以匹配
到 xinxing。 
\ 为转义字符前缀，如果我们想匹配“xin.”，但是“.”的地位有点特殊，我们可
以在其前面加一个反斜线表示转义，比如我们用 xin\.来匹配
xin.这样子。 
5.由于$命令是移动光标到行尾，所以 d$命令就是删除当前光
标到行尾的内容，而且该行的最后一个字符也会被删除。 
## cc and cw and ce and c$
不过它在命令执行后会进入 Insert 模式。
比如 cw 命令会首先删除该 word，并且会立即进入插入模式。 
## dd 命令可以删除整行，而 cc 命令则可以改变整行。 
## x 其实就是 dl，
表示删除当前光标下的字符，
## X 命令则是 dh
表示删除当前光标左边的字符。
## D 表示 d$,表示删除到行尾的内容
## C 表示 c$
 表示修改到行尾的内容
## s 表示 cl，
即修改一个字符，
## S 表示 cc
即修改一整行内容。 
## 对于某些喜欢钻牛角尖的童鞋来说，它发现 4dw 和 d4w 是
一样的，都是删除四个单词，但是 4dw 是对 dw 命令执行了四
次，每次删除一个单词，执行了四次会删除四个单词，而 d4w
则是执行了一次命令，删除了四个单词。比如 4d2w 则是每次
删除两个单词，重复删除 4 次，因此共计删除了八个单词。 
## r 命令则是把当前位置的字符被我们键入的字符所替换，比
如 rx 则是用 x 来替换当前位置的字符，而 5rx 表示从该字符 之
后的五个字符都是用 x 来替换。 
## 而我们用 r 之后按回车键，则会删除一个字符并且插入一个
换行符，
## 而 r4<Enter> 即我们按下 r 键和 4 键之后再按回车，
会把接下来的四个字符替换为一个换行符。 
 
## . 命令
vim 下重复操作很简单，
我们使用.命令。 
输入/a 来找到所有的 a 字符，截图
然后我们用在命令模式下键入 clb，此时我们把这里的 a 换成
了 b，然后我们在用 Esc 键退回到命令模式下： 
 
5.然后我们用 n 命令来找到下一个被查找出的 a 字符，如下截
图：2014 年辛星 vim 教程秋季版 
 
6.然后我们键入一个.然后我们会发现： 
 
7.然后我们多按几次 n 命令和.命令，之后发现： 
## p
命令把它取出来，这里的 p 是 put 的意思，即“拿出，取出”，
如果单纯的为了记忆，理解为 paste 也不错，即“粘贴”，但是
它并不是 vim 的思维模式，是微软党的思维模式。 
3.如果我们删除的一整行的内容，比如使用了 dd 命令，那么 p
命令会把整个文本行都放到光标下面作为单独的一行。如果我
们删除的是一行的部分内容，比如一个 word，那么 p 命令就
会把这部分内容放到当前光标的后面。 
## P
命令（大写的 P）和小写的 p 命令很相似，只是它会把该内
容粘贴到光标字符之前。对于 dd 删除的整行内容，我们用 P
命令会把它放到当前行的上一行，对于 dw 删除的部分内容，P
会把它放到光标之前。 
5.就像一次复制可以多次粘贴一样，我们可以多次重复使用 p
命令。 
6.该命令依然支持命令计数，比如 3p 命令表示把被删除的 3 份
副本放到当前位置。 
7.这里说一个小窍门把：有时候我们会一时打错东西，比如把
the 打成了 teh，那么我们可以在命令模式下用 dlp 或者 xp 来
把 teh 换成 the，dl 和 x 命令都表示删除 e 字符，而 p 会把它粘
贴到 h 字符之后。 
## y
命令，这里的 y 是“yank ”的意思，翻译成汉语即“拉，抽”。
9.其实用 copy 来表示复制更好理解点，但是很可惜 c 命令同时
也是“change ”的第一个字母，该命令用于表示修改，所以也
就没办法用 c 命令表示复制了，只能用 yank 的 y 命令表示复制。  
10.就像我们的 d4w 表示剪切四个 word 一样，我们的 y4 w 表
示复制四个 word。 
11.需要注意的是，y4w 会把 wo rd 之后的空白字符也给复制过
去，如果我们不想复制该空白字符，那么我们可以用 y4e。 
12.就像 dd 表示删除一行一样，我们可以 用 yy 来表示复制一
行，Y 命令也是复制整行的内容，
## y$命令则是复制当前光标
所在位置至行尾的命令。 
** sentence
   das 如果我们想删除一个句子，我们也希望删除它后面的空白， 就用 das，
   cis 如果我们用新的文本替换它，空白是保留下来的
2er 时候我们希望用新输入的文本来代替那些已经存在的文本，
此时就可以在命令模式下输入 R 来进入替换模式。 
*******************小结**************************** 
1.这一节我们的知识点主要分为两大块。 
2.第 一 大块 就是 知 道如 何 移动 光标 ， 比如 左 下上 右地 移 动光 标 ，
比如如何一次移动四个单词这样的移动方式。 
3.第二大块就是知道如何对文本进行操作，比如剪切、赋值、
粘贴、搜索、替换、重复执行命令等一系列操作。 
4.vim 的操作无难度，它是一学就会的，但是想要用起来得心
应手，还是需要大量的练习的，还有就是对各种命令的记忆。 
** file
   + :e
   + spc-f-s  <->  :w
   + :sav
   + :enew
   + :close
   + :wqa
   + :set filetype=php
- :set  background=dark (注：默认的情况下使用的 background 是 light)  
** window
## :split
## :close
## :only
来关闭其他窗口。 
## :split  qian.php
## :vsplit
** tabedit  xin
tabedit 是 tab (标签页)和 edit(编辑)的合写，
** _vimrc
#宏命令_记录与回放
.命令可以重复最近一次的编辑操作，但是，当我们操作很复杂的时候，或
者我们需要重复的操作变多的时候，又该怎么办呢? 
2.强劲的 vim 自然也考虑到了这一点，
在 vim 中我们这么做通
##使用 q{寄存器名}
开始命令，后续的操作会被记录到该寄存器中，这里的寄存器名必须是 a 到 z 之间的
一个字母。第二步，执行我们的那些繁杂的操作。第三步，按
下 q 表示结束对命令的录制。 
3.我们可以通过@{寄存器名}命令来执行刚刚记录下来的宏了。
其实，支持宏的文本编辑器还是有不少的，但是，支持的比
vim 还强大的，倒是没几个。 
8.然后咱们执行命令 3@x,之后效果如下：2014 年辛星 vim 教程秋季版 
 
10.由于我们最多可以定义 a-z 等 26 个字母可用，因此，我们可
以定义最多 26 个宏，这对于简化咱们的操作是很不错的。 
宏，说明一下，这里的”是双引号，这里的 x 是咱们的宏的名字，
如果你并没有用 x 作为宏的名字，那么相应的命令替换为你的
宏名，下面是该宏的截图： 
#:s
命令或者其全称:substitute 命令。 
：s/查找字符/替换字符/[可选的修饰符] 
##可选的修饰符

** code utf-8 font IM
*** code know
    个人觉得按时间线的脉络来说比较直观，具体细节不阐明，因为我也不懂，时间线的前
    后有出入我也不管，我认为理解了概念后能用就行，其它的都是专业人员的事情喽！
    - 语言与文字，笔与纸，这里不是同一个范畴，不说。
    - 打字机与打印纸是一对一，字符集也可以说就是文字，此处不涉及显示，因为你打的是
      什么字母在纸上就显示什么。
    - 早期的字符终端系统是用 BIOS 供应的 VGA 功能来显示字符
      操作系统的没有编码之说，操作系统是依靠 BIOS 的编码的。
      早期的 IBM 就把这个 BIOS 的编码称为代码页，它自己用的称为 OEM 代码页 。
    - 后来操作系统发展了，需要支持多种的文字，操作系统就进化到使用自己的字符呈现引擎
      来支持很多不同的字符，不同文字即为不同的字符集，英文字母是吃螃蟹的，叫做 ASCII
      拉丁文多些就在 ASCII 上扩展了叫 EASCII 方案，它还是基于 ANSII 扩展的是全兼容的，
      因为还是一个字节就够了，当然方块字需要出场了，128 不够了。国人就用高位来借了，
      符来表示一个汉字，大概也就在这段时间，繁体字，韩文，日文大家都只有用高位来借，
      但简体与繁体，日文中的汉字，韩文中的汉字怎么编码，其实这时大家都各搞自己的一套，
      我想此时各自有各自的字符集，相应的编码也是有自己的编法，此时代码页也就别称为字符
      编码了，代码页就为曾用名了，但微软或老的程序员还是用代码页来称呼。
      许多字对应的编码是不同的，字符集（charset）和字符编码（encoding）就不是一个概念。
    - 字符集 Unicode 是一个 ISO 类型标准方案，不管实现，以前各自为政有多个字符集，字符集
      里的字符集合也可称为字符集，它和字符的二进制编码的一一对应。
      字符编码是实现（显示与输入 IO），这是操作系统来控制的，它来转换各种存储和编码
    - utf-8 是存储与传输的格式，是以 Unicode 的标准来编码实现的
    - ANSII 储存显示基本只能是拉丁文
        Unicode/UCS2 字符集可储存显示全世界的，浪费存储空间也网络传输也浪费
        UCS4 当然更加浪费了。因此 Unicode/UCS 的压缩形式－－UTF8 就出现了。
    - 操作系统只能有一种自己内含的字符编码，当它打开文件时它有函数来判断此文件是以那种字符
        编码来打开的，如果与自己内含的相同就直接打开，如果不同还需转码成自己内含的才能打开的。 
        操作系统之上的所有显示软件都是与自己内含的。
        抄的编码其实有 2 个意思。
        一个是把字符和数字对应起来（比如 unicode 和 GBXXXX 等）。
        二是相应在数字在计算机中的表示，也就是和字节序列对应起来（比如 utf8，mbcs 等）
    - 键盘也有编码，还有字体的体现，  
     1) code page
        中文名－代码页
        别称－内码表
        原名－字符集编码
        实例－OEM（代码页）
     2) 历史
        用 BIOS 供应的 VGA 功能来显示字符，操作系统的编码支持也就依靠 BIOS 的编码。
        用 BIOS 供应的 VGA 功能来显示字符，操作系统的编码支持也就依靠 BIOS 的编码。
        现在这 BIOS 代码页被称为 OEM 代码页
        因为图形操作系统使用自己字符呈现引擎可以支持很多不同的字符集编码。
        早期 IBM 和微软内部使用特别数字（现在中文就是 936）来标记这些编码。
     3) 字符集和字符编码
        前面说过在图形系统支持字符之前用的是 BISO 的编码，当时是没有必要区别字符集
        与字符编码，因此 ASCII 也现在也可称字符编码。后来图形操作系统支持了，就提出
        字符集这个概念，是为了大家统一重新建了一个上层抽像，不管实现。
百科搜代码页，wiz 关于字符集和字符编码以及代码页的前前后后
字体（库）是与字符集有关系的，而所谓的乱码，则是与字符编码有关系的
链接：http://www.zhihu.com/question/20908598/answer/55785273
完成字形设计后，需要软件开发人员使用 TrueType 语言编写每个字的指令序列，
除了描述坐标及笔画走向之外，有些字还要编写显示控制指令，确保其显示结果不失真。TrueType
是由 Apple 公司和 Microsoft 公司联合提出的一种字形描述语言，该技术提供了字形描述的方法
和指令，用这些指令可以编写出各种各样的字库程序，产生 TrueType 字库
*** emacs coding
  org 模式的头文件用这个格式-*- coding: gbk -*- (UTF-8 or GBK)
1. describe-coding-system
   c-h C
   查看系统里有什么类型的编码

1. describe-current-coding-system
   出现一个 buffer 提示 emacs 编码配置
   当前缓冲区是什么
   默认的为新建的文件是什以编码
   键盘 IO 是什么编码等等
   还有终端与客户端的编码，$$$$
   最后会出现你打开文件时的判断编码的顺序说明
2. revert-buffer-with-coding-system
   C-x RET r
   重新指定编码来重新读入这个文件。

3. 如果要把缓冲区的编码在 unix 与 dos 间互相转换
   C-x RET f
   set-buffer-file-coding-system  

4. 不改变当前文件编码，但将该文件另存为 utf-8 编码格式：
   C-x RET c
   universal-coding-system-argument
   用给定的编码系统执行一个 I/O 命令
   UTF-8，然后再用 C-c C-s 命令保存当前的文件。

5. prefer-coding-system
   提升当前的代码顺序
